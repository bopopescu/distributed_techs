# Java并发编程与高并发解决方案

**并发编程知识体系**：线程安全、线程封闭、线程调度、同步容器、并发容器、AQS、J.U.C。

**高并发解决思路与手段**：扩容、缓存、队列、拆分、服务降级与熔断、数据库切库、分库分表。

![](E:\GIT\distributed_techs\imgs\java并发编程相关图例\1.jpg)

## 1. 并发与并发的线程安全处理

![](E:\GIT\distributed_techs\imgs\java并发编程相关图例\2.jpg)

**并发**：同时拥有两个或多个线程，如果程序在单核处理器上运行，多个线程将交替地换人换出内存，这些线程是同时“存在”的，每个线程处于执行过程中的某个状态，如果运行在多核处理器上，此时程序中的每个线程都将分配到一个处理核上，因此可以同时运行。

**高并发（High Concurrency）**：是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指通过设计保证系统能够同时并行处理很多请求。

并发指多个线程操作相同资源，此时讨论的点更多是**保证线程安全及合理使用资源**。而高并发指系统集中收到大量请求，会导致系统在这段时间内执行大量操作，如数据库、资源请求等，若高并发处理不好不仅会降低用户体验，请求时间变长，OOM异常甚至导致系统宕机停止工作；若要系统能够适应高并发的状态，需要从多个方面进行系统优化包括硬件、网络、系统架构、开发语言的选取、数据结构的运用、算法优化、数据库优化等，这时关注的是如何**提高程序的性能**，更多是对高并发场景提供解决方案、思路和手段。

### 1.1 CPU多级缓存与MESI协议

![](E:\GIT\distributed_techs\imgs\java并发编程相关图例\CPU多级缓存.PNG)

为什么需要缓存？CPU频率太快，快到主存跟不上，这样在处理的时钟周期内，CPU常常需要等待主存，浪费资源。缓存的出现是为了缓解CPU和主存之间速度不匹配问题。缓存容量有效，缓存的意义主要有两点：

1. 时间局部性，如果某个数据被访问，那么在不久的将来它很有可能被再次访问；
2. 空间局部性，如果某个数据被访问，那么与它相邻的数据很快也可能被访问；

**Cache一致性协议之MESI**

单核Cache中每个Cache line有2个标志：dirty和valid标志，它们很好的描述了Cache和Memory(内存)之间的数据关系(数据是否有效，数据是否被修改)，而在多核处理器中，多个核会共享一些数据，MESI协议就包含了描述共享的状态。   在MESI协议中，每个Cache line有4个状态，可用2个bit表示，它们分别是：

| 状态      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| Modify    | 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中 |
| Exclusive | 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中  |
| Share     | 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。 |
| Invalid   | 这行数据无效                                                 |

**MESI用于保证多个CPU缓存之间缓存共享数据的一致性**，定义了缓存行的的四种状态，而CPU对缓存的四种操作可能会产生不一致的状态，因此缓存控制器监听到本地操作和远程操作时，需要对cache line做一定的修改，保证数据在多个缓存间的一致性。  

在MESI协议中，每个Cache的Cache控制器不仅知道自己的读写操作，而且也监听(snoop)其它Cache的读写操作。每个Cache line所处的状态根据本核和其它核的读写操作在4个状态间进行迁移。 

![](E:\GIT\distributed_techs\imgs\java并发编程相关图例\MESI协议状态迁移图.gif)

在上图中，Local Read表示本内核读本Cache中的值，Local Write表示本内核写本Cache中的值，Remote Read表示其它内核读其它Cache中的值，Remote Write表示其它内核写其它Cache中的值，箭头表示本Cache line状态的迁移，环形箭头表示状态不变。 

当内核需要访问的数据不在本Cache中，而其它Cache有这份数据的备份时，本Cache既可以从内存中导入数据，也可以从其它Cache中导入数据，不同的处理器会有不同的选择。MESI协议为了使自己更加通用，没有定义这些细节，只定义了状态之间的迁移，下面的描述假设本Cache从内存中导入数据。 

- I-无效状态

  | 事件           | 行为                                                         | 下一状态 |
  | -------------- | ------------------------------------------------------------ | -------- |
  | Local Read     | 如果其它Cache没有这份数据，本Cache从内存中取数据，Cache line状态变成E；  如果其它Cache有这份数据，且状态为M，则将数据更新到内存，本Cache再从内存中取数据，2个Cache 的Cache line状态都变成S；  如果其它Cache有这份数据，且状态为S或者E，本Cache从内存中取数据，这些Cache 的Cache line状态都变成S | E/S      |
  | Local Write| 从内存中取数据，在Cache中修改，状态变成M；  如果其它Cache有这份数据，且状态为M，则要先将数据更新到内存；  如果其它Cache有这份数据，则其它Cache的Cache line状态变成I | M        |
  | Remote Read| 既然是Invalid，别的核的操作与它无关                          | I        |
  | Remote Write | 既然是Invalid，别的核的操作与它无关                          | I        |

- E-独享状态

  | 事件         | 行为                          | 下一状态 |
  | ------------ | ----------------------------- | -------- |
  | Local Read   | 从Cache中取数据，状态不变     | E        |
  | Local Write  | 修改Cache中的数据，状态变成M  | M        |
  | Remote Read  | 数据和其它核共用，状态变成了S | S        |
  | Remote Write | 数据和其它核共用，状态变成了S | I        |

- S-共享状态

  | 事件         | 行为                                                         | 下一状态 |
  | ------------ | ------------------------------------------------------------ | -------- |
  | Local Read   | 从Cache中取数据，状态不变                                    | S        |
  | Local Write  | 修改Cache中的数据，状态变成M； 其它核共享的Cache line状态变成I | M        |
  | Remote Read  | 状态不变                                                     | S        |
  | Remote Write | 状态不变                                                     | I        |

- M-已修改状态

  | 事件         | 行为                                                         | 下一状态 |
  | ------------ | ------------------------------------------------------------ | -------- |
  | Local Read   | 从Cache中取数据，状态不变                                    | M        |
  | Local Write  | 修改Cache中的数据，状态不变                                  | M        |
  | Remote Read  | 这行数据被写到内存中，使其它核能使用到最新的数据，状态变成S  | S        |
  | Remote Write | 这行数据被写到内存中，使其它核能使用到最新的数据，由于其它核会修改这行数据， | I        |

### 1.2 **乱序执行优化**

通过改变原有执行顺序而减少时间的执行过程我们被称之为**乱序执行*,也称为*重排* 。随着处理器流水线技术和多核技术的发展,目前的高级处理器通过提高内部逻辑元件的利用率来提高运行速度，通常会采用乱序执行技术。

![](E:\GIT\distributed_techs\imgs\java并发编程相关图例\乱序执行.PNG)

可以说乱序执行技术是处理器为提高运算速度而做出违背代码原有顺序的优化。在单核时代，处理器保证做出的优化不会导致执行结果远离预期目标，但在多核环境下却并非如此.。

首先多核时代，同时会有多个核执行指令，每个核的指令都可能被乱序；另外，处理器还引入了L1、L2等缓存机制，每个核都有自己的缓存，这就导致逻辑次序上后写入内存的数据未必真的最后写入。最终带来了这么一个问题：如果我们不做任何防护措施，处理器最终得出的结果和我们逻辑得出的结果大不相同。比如我们在一个核上执行数据的写入操作，并在最后写一个标记用来表示之前的数据已经准备好，然后从另一个核上通过判断这个标志来判定所需要的数据已经就绪，这种做法存在风险：标记位先被写入，但是之前的数据操作却并未完成(可能是未计算完成，也可能是数据没有从处理器缓存刷新到主存当中)，最终导致另一个核中使用了错误的数据。

所有可能发生乱序执行的情况如下：

- 现代处理器采用指令并行技术，在不存在数据依赖性的前提下，处理器可以改变语句对应的机器指令的执行顺序来提高处理器执行速度。
- 现代处理器采用内部缓存技术，导致数据的变化不能及时反映在主存所带来的乱序。
- 现代编译器为优化而重新安排语句的执行顺序。



## 2. 高并发处理的思路及手段 

![](E:\GIT\distributed_techs\imgs\java并发编程相关图例\3.jpg)

















